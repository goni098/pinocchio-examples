/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type AccountMeta,
	type AccountSignerMeta,
	type Address,
	combineCodec,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	type Instruction,
	type InstructionWithAccounts,
	type InstructionWithData,
	type ReadonlySignerAccount,
	type ReadonlyUint8Array,
	type TransactionSigner,
	transformEncoder,
	type WritableAccount
} from "@solana/kit"
import { COUNTER_PROGRAM_ADDRESS } from "../programs"
import { getAccountMetaFactory, type ResolvedAccount } from "../shared"

export const INCREASE_COUNTER_AUTHORITY_DISCRIMINATOR = 3

export function getIncreaseCounterAuthorityDiscriminatorBytes() {
	return getU8Encoder().encode(INCREASE_COUNTER_AUTHORITY_DISCRIMINATOR)
}

export type IncreaseCounterAuthorityInstruction<
	TProgram extends string = typeof COUNTER_PROGRAM_ADDRESS,
	TAccountAuthority extends string | AccountMeta<string> = string,
	TAccountCounterAuthority extends string | AccountMeta<string> = string,
	TRemainingAccounts extends readonly AccountMeta<string>[] = []
> = Instruction<TProgram> &
	InstructionWithData<ReadonlyUint8Array> &
	InstructionWithAccounts<
		[
			TAccountAuthority extends string
				? ReadonlySignerAccount<TAccountAuthority> & AccountSignerMeta<TAccountAuthority>
				: TAccountAuthority,
			TAccountCounterAuthority extends string
				? WritableAccount<TAccountCounterAuthority>
				: TAccountCounterAuthority,
			...TRemainingAccounts
		]
	>

export type IncreaseCounterAuthorityInstructionData = { discriminator: number }

export type IncreaseCounterAuthorityInstructionDataArgs = {}

export function getIncreaseCounterAuthorityInstructionDataEncoder(): FixedSizeEncoder<IncreaseCounterAuthorityInstructionDataArgs> {
	return transformEncoder(getStructEncoder([["discriminator", getU8Encoder()]]), value => ({
		...value,
		discriminator: INCREASE_COUNTER_AUTHORITY_DISCRIMINATOR
	}))
}

export function getIncreaseCounterAuthorityInstructionDataDecoder(): FixedSizeDecoder<IncreaseCounterAuthorityInstructionData> {
	return getStructDecoder([["discriminator", getU8Decoder()]])
}

export function getIncreaseCounterAuthorityInstructionDataCodec(): FixedSizeCodec<
	IncreaseCounterAuthorityInstructionDataArgs,
	IncreaseCounterAuthorityInstructionData
> {
	return combineCodec(
		getIncreaseCounterAuthorityInstructionDataEncoder(),
		getIncreaseCounterAuthorityInstructionDataDecoder()
	)
}

export type IncreaseCounterAuthorityInput<
	TAccountAuthority extends string = string,
	TAccountCounterAuthority extends string = string
> = {
	authority: TransactionSigner<TAccountAuthority>
	counterAuthority: Address<TAccountCounterAuthority>
}

export function getIncreaseCounterAuthorityInstruction<
	TAccountAuthority extends string,
	TAccountCounterAuthority extends string,
	TProgramAddress extends Address = typeof COUNTER_PROGRAM_ADDRESS
>(
	input: IncreaseCounterAuthorityInput<TAccountAuthority, TAccountCounterAuthority>,
	config?: { programAddress?: TProgramAddress }
): IncreaseCounterAuthorityInstruction<
	TProgramAddress,
	TAccountAuthority,
	TAccountCounterAuthority
> {
	// Program address.
	const programAddress = config?.programAddress ?? COUNTER_PROGRAM_ADDRESS

	// Original accounts.
	const originalAccounts = {
		authority: { value: input.authority ?? null, isWritable: false },
		counterAuthority: {
			value: input.counterAuthority ?? null,
			isWritable: true
		}
	}
	const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>

	const getAccountMeta = getAccountMetaFactory(programAddress, "programId")
	return Object.freeze({
		accounts: [getAccountMeta(accounts.authority), getAccountMeta(accounts.counterAuthority)],
		data: getIncreaseCounterAuthorityInstructionDataEncoder().encode({}),
		programAddress
	} as IncreaseCounterAuthorityInstruction<
		TProgramAddress,
		TAccountAuthority,
		TAccountCounterAuthority
	>)
}

export type ParsedIncreaseCounterAuthorityInstruction<
	TProgram extends string = typeof COUNTER_PROGRAM_ADDRESS,
	TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[]
> = {
	programAddress: Address<TProgram>
	accounts: {
		authority: TAccountMetas[0]
		counterAuthority: TAccountMetas[1]
	}
	data: IncreaseCounterAuthorityInstructionData
}

export function parseIncreaseCounterAuthorityInstruction<
	TProgram extends string,
	TAccountMetas extends readonly AccountMeta[]
>(
	instruction: Instruction<TProgram> &
		InstructionWithAccounts<TAccountMetas> &
		InstructionWithData<ReadonlyUint8Array>
): ParsedIncreaseCounterAuthorityInstruction<TProgram, TAccountMetas> {
	if (instruction.accounts.length < 2) {
		// TODO: Coded error.
		throw new Error("Not enough accounts")
	}
	let accountIndex = 0
	const getNextAccount = () => {
		const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!
		accountIndex += 1
		return accountMeta
	}
	return {
		programAddress: instruction.programAddress,
		accounts: {
			authority: getNextAccount(),
			counterAuthority: getNextAccount()
		},
		data: getIncreaseCounterAuthorityInstructionDataDecoder().decode(instruction.data)
	}
}
