/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Account,
	assertAccountExists,
	assertAccountsExist,
	type Codec,
	combineCodec,
	type Decoder,
	decodeAccount,
	type EncodedAccount,
	type Encoder,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	getU64Decoder,
	getU64Encoder,
	type MaybeAccount,
	type MaybeEncodedAccount
} from "@solana/kit"
import { type Address, type AddressArgs, getAddressDecoder, getAddressEncoder } from "../types"

export type CounterAuthority = {
	authority: Address
	bump: number
	count: bigint
}

export type CounterAuthorityArgs = {
	authority: AddressArgs
	bump: number
	count: number | bigint
}

/** Gets the encoder for {@link CounterAuthorityArgs} account data. */
export function getCounterAuthorityEncoder(): Encoder<CounterAuthorityArgs> {
	return getStructEncoder([
		["authority", getAddressEncoder()],
		["bump", getU8Encoder()],
		["count", getU64Encoder()]
	])
}

/** Gets the decoder for {@link CounterAuthority} account data. */
export function getCounterAuthorityDecoder(): Decoder<CounterAuthority> {
	return getStructDecoder([
		["authority", getAddressDecoder()],
		["bump", getU8Decoder()],
		["count", getU64Decoder()]
	])
}

/** Gets the codec for {@link CounterAuthority} account data. */
export function getCounterAuthorityCodec(): Codec<CounterAuthorityArgs, CounterAuthority> {
	return combineCodec(getCounterAuthorityEncoder(), getCounterAuthorityDecoder())
}

export function decodeCounterAuthority<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>
): Account<CounterAuthority, TAddress>
export function decodeCounterAuthority<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<CounterAuthority, TAddress>
export function decodeCounterAuthority<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<CounterAuthority, TAddress> | MaybeAccount<CounterAuthority, TAddress> {
	return decodeAccount(
		encodedAccount as MaybeEncodedAccount<TAddress>,
		getCounterAuthorityDecoder()
	)
}

export async function fetchCounterAuthority<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<Account<CounterAuthority, TAddress>> {
	const maybeAccount = await fetchMaybeCounterAuthority(rpc, address, config)
	assertAccountExists(maybeAccount)
	return maybeAccount
}

export async function fetchMaybeCounterAuthority<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<MaybeAccount<CounterAuthority, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config)
	return decodeCounterAuthority(maybeAccount)
}

export async function fetchAllCounterAuthority(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<Account<CounterAuthority>[]> {
	const maybeAccounts = await fetchAllMaybeCounterAuthority(rpc, addresses, config)
	assertAccountsExist(maybeAccounts)
	return maybeAccounts
}

export async function fetchAllMaybeCounterAuthority(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<MaybeAccount<CounterAuthority>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
	return maybeAccounts.map(maybeAccount => decodeCounterAuthority(maybeAccount))
}
