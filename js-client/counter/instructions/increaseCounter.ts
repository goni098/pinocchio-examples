/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type AccountMeta,
	type Address,
	combineCodec,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	type Instruction,
	type InstructionWithAccounts,
	type InstructionWithData,
	type ReadonlyUint8Array,
	transformEncoder,
	type WritableAccount
} from "@solana/kit"
import { COUNTER_PROGRAM_ADDRESS } from "../programs"
import { getAccountMetaFactory, type ResolvedAccount } from "../shared"

export const INCREASE_COUNTER_DISCRIMINATOR = 1

export function getIncreaseCounterDiscriminatorBytes() {
	return getU8Encoder().encode(INCREASE_COUNTER_DISCRIMINATOR)
}

export type IncreaseCounterInstruction<
	TProgram extends string = typeof COUNTER_PROGRAM_ADDRESS,
	TAccountCounter extends string | AccountMeta<string> = string,
	TRemainingAccounts extends readonly AccountMeta<string>[] = []
> = Instruction<TProgram> &
	InstructionWithData<ReadonlyUint8Array> &
	InstructionWithAccounts<
		[
			TAccountCounter extends string ? WritableAccount<TAccountCounter> : TAccountCounter,
			...TRemainingAccounts
		]
	>

export type IncreaseCounterInstructionData = { discriminator: number }

export type IncreaseCounterInstructionDataArgs = {}

export function getIncreaseCounterInstructionDataEncoder(): FixedSizeEncoder<IncreaseCounterInstructionDataArgs> {
	return transformEncoder(getStructEncoder([["discriminator", getU8Encoder()]]), value => ({
		...value,
		discriminator: INCREASE_COUNTER_DISCRIMINATOR
	}))
}

export function getIncreaseCounterInstructionDataDecoder(): FixedSizeDecoder<IncreaseCounterInstructionData> {
	return getStructDecoder([["discriminator", getU8Decoder()]])
}

export function getIncreaseCounterInstructionDataCodec(): FixedSizeCodec<
	IncreaseCounterInstructionDataArgs,
	IncreaseCounterInstructionData
> {
	return combineCodec(
		getIncreaseCounterInstructionDataEncoder(),
		getIncreaseCounterInstructionDataDecoder()
	)
}

export type IncreaseCounterInput<TAccountCounter extends string = string> = {
	counter: Address<TAccountCounter>
}

export function getIncreaseCounterInstruction<
	TAccountCounter extends string,
	TProgramAddress extends Address = typeof COUNTER_PROGRAM_ADDRESS
>(
	input: IncreaseCounterInput<TAccountCounter>,
	config?: { programAddress?: TProgramAddress }
): IncreaseCounterInstruction<TProgramAddress, TAccountCounter> {
	// Program address.
	const programAddress = config?.programAddress ?? COUNTER_PROGRAM_ADDRESS

	// Original accounts.
	const originalAccounts = {
		counter: { value: input.counter ?? null, isWritable: true }
	}
	const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>

	const getAccountMeta = getAccountMetaFactory(programAddress, "programId")
	return Object.freeze({
		accounts: [getAccountMeta(accounts.counter)],
		data: getIncreaseCounterInstructionDataEncoder().encode({}),
		programAddress
	} as IncreaseCounterInstruction<TProgramAddress, TAccountCounter>)
}

export type ParsedIncreaseCounterInstruction<
	TProgram extends string = typeof COUNTER_PROGRAM_ADDRESS,
	TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[]
> = {
	programAddress: Address<TProgram>
	accounts: {
		counter: TAccountMetas[0]
	}
	data: IncreaseCounterInstructionData
}

export function parseIncreaseCounterInstruction<
	TProgram extends string,
	TAccountMetas extends readonly AccountMeta[]
>(
	instruction: Instruction<TProgram> &
		InstructionWithAccounts<TAccountMetas> &
		InstructionWithData<ReadonlyUint8Array>
): ParsedIncreaseCounterInstruction<TProgram, TAccountMetas> {
	if (instruction.accounts.length < 1) {
		// TODO: Coded error.
		throw new Error("Not enough accounts")
	}
	let accountIndex = 0
	const getNextAccount = () => {
		const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!
		accountIndex += 1
		return accountMeta
	}
	return {
		programAddress: instruction.programAddress,
		accounts: { counter: getNextAccount() },
		data: getIncreaseCounterInstructionDataDecoder().decode(instruction.data)
	}
}
