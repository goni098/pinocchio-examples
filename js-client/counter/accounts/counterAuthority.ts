/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Account,
	type Address,
	assertAccountExists,
	assertAccountsExist,
	combineCodec,
	decodeAccount,
	type EncodedAccount,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getBytesDecoder,
	getBytesEncoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	getU64Decoder,
	getU64Encoder,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type ReadonlyUint8Array
} from "@solana/kit"

export type CounterAuthority = {
	authority: ReadonlyUint8Array
	bump: number
	count: bigint
}

export type CounterAuthorityArgs = {
	authority: ReadonlyUint8Array
	bump: number
	count: number | bigint
}

/** Gets the encoder for {@link CounterAuthorityArgs} account data. */
export function getCounterAuthorityEncoder(): FixedSizeEncoder<CounterAuthorityArgs> {
	return getStructEncoder([
		["authority", fixEncoderSize(getBytesEncoder(), 32)],
		["bump", getU8Encoder()],
		["count", getU64Encoder()]
	])
}

/** Gets the decoder for {@link CounterAuthority} account data. */
export function getCounterAuthorityDecoder(): FixedSizeDecoder<CounterAuthority> {
	return getStructDecoder([
		["authority", fixDecoderSize(getBytesDecoder(), 32)],
		["bump", getU8Decoder()],
		["count", getU64Decoder()]
	])
}

/** Gets the codec for {@link CounterAuthority} account data. */
export function getCounterAuthorityCodec(): FixedSizeCodec<CounterAuthorityArgs, CounterAuthority> {
	return combineCodec(getCounterAuthorityEncoder(), getCounterAuthorityDecoder())
}

export function decodeCounterAuthority<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>
): Account<CounterAuthority, TAddress>
export function decodeCounterAuthority<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<CounterAuthority, TAddress>
export function decodeCounterAuthority<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<CounterAuthority, TAddress> | MaybeAccount<CounterAuthority, TAddress> {
	return decodeAccount(
		encodedAccount as MaybeEncodedAccount<TAddress>,
		getCounterAuthorityDecoder()
	)
}

export async function fetchCounterAuthority<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<Account<CounterAuthority, TAddress>> {
	const maybeAccount = await fetchMaybeCounterAuthority(rpc, address, config)
	assertAccountExists(maybeAccount)
	return maybeAccount
}

export async function fetchMaybeCounterAuthority<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<MaybeAccount<CounterAuthority, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config)
	return decodeCounterAuthority(maybeAccount)
}

export async function fetchAllCounterAuthority(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<Account<CounterAuthority>[]> {
	const maybeAccounts = await fetchAllMaybeCounterAuthority(rpc, addresses, config)
	assertAccountsExist(maybeAccounts)
	return maybeAccounts
}

export async function fetchAllMaybeCounterAuthority(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<MaybeAccount<CounterAuthority>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
	return maybeAccounts.map(maybeAccount => decodeCounterAuthority(maybeAccount))
}

export function getCounterAuthoritySize(): number {
	return 41
}
