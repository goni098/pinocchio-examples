/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Account,
	type Address,
	assertAccountExists,
	assertAccountsExist,
	combineCodec,
	decodeAccount,
	type EncodedAccount,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	getU64Decoder,
	getU64Encoder,
	type MaybeAccount,
	type MaybeEncodedAccount
} from "@solana/kit"

export type Counter = { bump: number; count: bigint }

export type CounterArgs = { bump: number; count: number | bigint }

/** Gets the encoder for {@link CounterArgs} account data. */
export function getCounterEncoder(): FixedSizeEncoder<CounterArgs> {
	return getStructEncoder([
		["bump", getU8Encoder()],
		["count", getU64Encoder()]
	])
}

/** Gets the decoder for {@link Counter} account data. */
export function getCounterDecoder(): FixedSizeDecoder<Counter> {
	return getStructDecoder([
		["bump", getU8Decoder()],
		["count", getU64Decoder()]
	])
}

/** Gets the codec for {@link Counter} account data. */
export function getCounterCodec(): FixedSizeCodec<CounterArgs, Counter> {
	return combineCodec(getCounterEncoder(), getCounterDecoder())
}

export function decodeCounter<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>
): Account<Counter, TAddress>
export function decodeCounter<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Counter, TAddress>
export function decodeCounter<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Counter, TAddress> | MaybeAccount<Counter, TAddress> {
	return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getCounterDecoder())
}

export async function fetchCounter<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<Account<Counter, TAddress>> {
	const maybeAccount = await fetchMaybeCounter(rpc, address, config)
	assertAccountExists(maybeAccount)
	return maybeAccount
}

export async function fetchMaybeCounter<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<MaybeAccount<Counter, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config)
	return decodeCounter(maybeAccount)
}

export async function fetchAllCounter(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<Account<Counter>[]> {
	const maybeAccounts = await fetchAllMaybeCounter(rpc, addresses, config)
	assertAccountsExist(maybeAccounts)
	return maybeAccounts
}

export async function fetchAllMaybeCounter(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<MaybeAccount<Counter>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
	return maybeAccounts.map(maybeAccount => decodeCounter(maybeAccount))
}

export function getCounterSize(): number {
	return 9
}
