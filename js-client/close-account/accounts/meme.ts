/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Account,
	type Address,
	assertAccountExists,
	assertAccountsExist,
	combineCodec,
	decodeAccount,
	type EncodedAccount,
	type FetchAccountConfig,
	type FetchAccountsConfig,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	fetchEncodedAccount,
	fetchEncodedAccounts,
	fixDecoderSize,
	fixEncoderSize,
	getBytesDecoder,
	getBytesEncoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	type MaybeAccount,
	type MaybeEncodedAccount,
	type ReadonlyUint8Array
} from "@solana/kit"

export type Meme = { address: ReadonlyUint8Array; bump: number }

export type MemeArgs = Meme

/** Gets the encoder for {@link MemeArgs} account data. */
export function getMemeEncoder(): FixedSizeEncoder<MemeArgs> {
	return getStructEncoder([
		["address", fixEncoderSize(getBytesEncoder(), 32)],
		["bump", getU8Encoder()]
	])
}

/** Gets the decoder for {@link Meme} account data. */
export function getMemeDecoder(): FixedSizeDecoder<Meme> {
	return getStructDecoder([
		["address", fixDecoderSize(getBytesDecoder(), 32)],
		["bump", getU8Decoder()]
	])
}

/** Gets the codec for {@link Meme} account data. */
export function getMemeCodec(): FixedSizeCodec<MemeArgs, Meme> {
	return combineCodec(getMemeEncoder(), getMemeDecoder())
}

export function decodeMeme<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress>
): Account<Meme, TAddress>
export function decodeMeme<TAddress extends string = string>(
	encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Meme, TAddress>
export function decodeMeme<TAddress extends string = string>(
	encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Meme, TAddress> | MaybeAccount<Meme, TAddress> {
	return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getMemeDecoder())
}

export async function fetchMeme<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<Account<Meme, TAddress>> {
	const maybeAccount = await fetchMaybeMeme(rpc, address, config)
	assertAccountExists(maybeAccount)
	return maybeAccount
}

export async function fetchMaybeMeme<TAddress extends string = string>(
	rpc: Parameters<typeof fetchEncodedAccount>[0],
	address: Address<TAddress>,
	config?: FetchAccountConfig
): Promise<MaybeAccount<Meme, TAddress>> {
	const maybeAccount = await fetchEncodedAccount(rpc, address, config)
	return decodeMeme(maybeAccount)
}

export async function fetchAllMeme(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<Account<Meme>[]> {
	const maybeAccounts = await fetchAllMaybeMeme(rpc, addresses, config)
	assertAccountsExist(maybeAccounts)
	return maybeAccounts
}

export async function fetchAllMaybeMeme(
	rpc: Parameters<typeof fetchEncodedAccounts>[0],
	addresses: Array<Address>,
	config?: FetchAccountsConfig
): Promise<MaybeAccount<Meme>[]> {
	const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config)
	return maybeAccounts.map(maybeAccount => decodeMeme(maybeAccount))
}

export function getMemeSize(): number {
	return 33
}
